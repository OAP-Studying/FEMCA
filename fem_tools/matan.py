# -*- coding: utf-8 -*-
"""
matan - модуль предоставляющий математическеи функции
для работы с матричными выражениями
можно сказать аналог numpy
"""
from copy import deepcopy


def minor_det(matrix, r, c):
    """
    Минор матрицы, стоящей на пересечении строки 'r' и столбца 'c'
    """
    # число строк ИСХОДНОЙ матрицы
    rows = len(matrix)
    # число столбцов ИСХОДНОЙ матрицы
    cols = len(matrix[0])

    # Создаём МИНОРНУЮ матрицу (rows-1)*(cols-1), заполняя элементами
    # из старой матрицы, но не учитывая строку 'r' и столбец 'c'
    minor_matrix = []
    # Счётчик строк новой матрицы, чтобы можно было её заполнять
    cnt_row = -1
    # Обходим СТРОКИ ИСХОДНОЙ матрицы
    for i in range(rows):
        # если строка ИСХОДНОЙ матрицы не равна вычеркнутой строке 'r'
        if i != r:
            # Можно заполнять строку новой матрицы
            minor_matrix.append([])
            # Увеличиваем счётчик строк новой матрицы
            cnt_row += 1
            # Обходим СТОЛБЦЫ ИСХОДНОЙ матрицы
            for j in range(cols):
                # если столбец ИСХОДНОЙ матрицы не равен вычеркнутому 'c'
                if j != c:
                    # Можно добавить этот элемент в строку минорной
                    minor_matrix[cnt_row].append(matrix[i][j])

    # После получения минорной матрицы находим её определитель
    # это и есть Минор - результат функции
    return determinant(minor_matrix)


def determinant(matrix):
    """Определитель матрицы"""
    # число строк матрицы
    rows = len(matrix)
    # число столбцов матрицы
    cols = len(matrix[0])

    # Если число строк матрицы = 1, то эта матрица
    # состоит из одного элемента
    # Определитель такой матрицы матрицы будет сам этот элемент
    if (rows == 1):
        return matrix[0][0]

    # Если матрица состоит из более чем одного элемента, то
    # Найдём определитель матрицы, разложив её по первой строке
    # Переменная для хранения результата работы функции
    res = 0
    for j in range(cols):
        # Если элемент строки равен нулю, то просто пропускаем его
        # Чтобы не затрачивать ресурсы на вычисление минорный определитель
        if matrix[0][j] != 0:
            # Вычисляем Алгебраическое дополнение
            # для каждого элемента строки
            A = ((-1)**(0+j)) * minor_det(matrix, r=0, c=j)
            # Прибавляем его к результату функции
            res += A*matrix[0][j]

    # возвращаем резултат работы функции
    return res


def transpose(matrix):
    """Возвращает транспонированную матрицу"""
    # Транспонировать - это значит поменять местами элементы
    # матрицы относительно главной диагонали
    # Будем считать что матрица квадратная

    # Матрица которая будет транспонированной
    matrix = deepcopy(matrix)

    # Число строк матрицы
    size = len(matrix)

    for i in range(size-1):
        # нам нужно обходить элементы только что ВЫШЕ
        # главной диагонали j=i
        for j in range(i+1, size):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

    # Возвращаем транспонированную матрицу
    return matrix


def inverse_matrix(matrix, det=None):
    """Нахождение обратной матрицы"""
    # Для ускорения вычислений, в функцию можно передать
    # Значение определителя

    # Если определитель матрыцы не был передан
    if not det:
        # Находим определитель матрицы
        det = determinant(matrix)

    # Если определитель матрицы равен нулю
    if det == 0:
        # вызываем исключение, так как не получится найти
        # Обратную матрицу
        raise Exception("Определитель матрицы = 0")

    # Определдитель не нулевой, тогда можно искать обратную матрицу

    # Считаем, что матрица квадратная
    # число строк матрицы
    size = len(matrix)

    # Соберём матрицу Алгебраических дополнений
    A_matrix = []
    # Обходим СТРОКИ ИСХОДНОЙ матрицы
    for i in range(size):
        # Добавляем новую строку к матрице Алг. дополнений
        A_matrix.append([])
        # Обходим столбцы ИСХОДНОЙ матрицы
        for j in range(size):
            # Вычисляем Алгебраическое дополнение
            # для каждого элемента
            A = ((-1)**(i+j)) * minor_det(matrix, r=i, c=j)
            # Добавляем его в матрицу Алг. дополнений
            A_matrix[i].append(A)

    # Транспонируем матрицу Алг. дополнений
    trans_A = transpose(A_matrix)

    # Теперь можно вычислить обратную матрицу
    # По формуле это транспонированная матрица
    # Алгебраических дополений, разделённая на определитель
    # Исходной матрицы
    # То есть все члены транспонированной матрицы Алг. дополнений
    # нужно умножить на число 1/det

    res_matrix = []
    for i in range(size):
        # Добавляем новую строку к результирующей - ОБРАТНОЙ матрице
        res_matrix.append([])
        for j in range(size):
            # Вычисляем элемент обратной матрицы
            el = (1/det) * trans_A[i][j]
            # Добавляем этот элемент к результирующей матрице
            res_matrix[i].append(el)

    # Возвращаем результат работы функции - обратную матрицу
    return res_matrix


def find_with_inv(A, Y):
    """
    Найти решение системы уравнений при помощи обратной матрицы
    A*X=Y -> возвращает вектор столбец X
    """
    # Решением будет обратная матрица матрице A умноженная на вектор солбец Y
    # Обратная матрица матрице A
    inv_A = inverse_matrix(A)
    # Переменная, для перебора элементов обратной матрицы A и вектора Y
    # Показывает размер их обоих
    size = len(Y)
    X = []
    for i in range(size):
        # Значение i-го элемента вектор-столбца X
        temp = 0
        for j in range(size):
            temp += inv_A[i][j] * Y[j]

        # Добавляем вычисленное значение в вектор столбец X
        X.append(temp)

    # Возвращаем вектор столбец X
    return X


def mult_line_and_num(line, k):
    """Умножить массив line на число k"""
    return [l*k for l in line]


def div_line_by_num(line, k):
    """Разделить массив line на число k"""
    return [l/k for l in line]


def add_lines(l1, l2, k=1):
    """
    Сложить две строки - массива
    l1 - первая строка
    l2 - вторая строки
    k - коэффициент в выражении l1 + l2*k
    """
    # создадим временный массив - результат выражения l2*k
    l2 = mult_line_and_num(l2, k)

    res = []
    for i in range(len(l1)):
        res.append(l1[i]+l2[i])

    # Возвращаем сумму двух массивов
    return res


def to_valid_diag(A, Y):
    """Привести систему уравнений A*X=Y к валидному виду"""
    # Чтобы бе проблем в методе Гаусса приводить матрицу к треугольному виду
    # нужно чтобы все диаголнальные элементы матрицы A - были не нулевыми

    # Чтобы случайно перезаписать передаваемые матрицу и вектор
    # Сделаем их локальные копии
    A = deepcopy(A)
    Y = deepcopy(Y)

    # размер матрицы A и столбца Y
    size = len(Y)

    # Обходим диагональные элементы матрицы A
    for i in range(size):
        # Если диагональный элемент матрицы нулевой
        if A[i][i] == 0:
            # обходим весь i-ый столбец
            for i_non_zero in range(size):
                # Чтобы найти номер строки в которой
                # попадётся неннулевой элемент
                if A[i_non_zero][i] != 0:
                    break
            # складываем текущую i-ую строку со строкой, где ненулевой элемент
            # Для матрицы A
            A[i] = add_lines(A[i], A[i_non_zero])
            # для столбца Y
            Y[i] += Y[i_non_zero]

    # Возвращаем матрицу A и Y, приведённые к валидному виду
    return A, Y


def triangulate(A, Y):
    """Привести систему уравнений A*X=Y к треугольному виду"""
    # Приводим систему к валидному виду
    A, Y = to_valid_diag(A, Y)

    # размер матрицы A и столбца Y
    size = len(Y)

    # Перебираем все строки матрицы
    for j in range(size):
        k = A[j][j]
        # В j-ой строке A[j][j] - точно НЕ равно 0
        # Делим всю строку на этот коэффициент
        A[j] = div_line_by_num(A[j], k)
        Y[j] /= k
        # Для всех последующих строк
        for i in range(j+1, size):
            k = A[i][j]
            # Если k = 0 то в нужной позиции уже стоит 0 и ничего делать не нао
            if k != 0:
                # в i-ой строке делим всю строку на коэффициент стоящий при
                # елементе A[i][j], чтобы в этой позиции получить 1-у
                A[i] = div_line_by_num(A[i], k)
                Y[i] /= k

                # Теперь из i-ой строки вычитаем j-ую строку
                # Чтобы получить 0 в позиции A[i][j]
                A[i] = add_lines(A[i], A[j], k=-1)
                Y[i] -= Y[j]

    # Воазвращаем систему приведённую к треугольному виду
    return A, Y


def find_with_gauss(A, Y):
    """
    Найти решение системы уравнений при помощи метода Гаусса
    A*X=Y -> возвращает вектор столбец X
    """
    # Приводим систему к треугольному виду
    A, Y = triangulate(A, Y)
    # размер матрицы A и столбца Y
    size = len(Y)
    # Возвращаемый вектор столбец X, предварительно заполняем его нулями
    X = [0 for _ in range(size)]
    # Начиная с последней строки, двигаясь вверх собираем вектор X
    for i in range(size-1, -1, -1):
        # Временная переменная для хранения значения i-го элемента столбца X
        # Сразу записываем туда элемент Y[i], т.к. в матрице A элемент A[i][i] = 1
        temp = Y[i]
        # Проходим все оставшиеся столбцы в строке
        for j in range(i+1, size):
            # Раскрываем линейную последовательность
            temp -= A[i][j]*X[j]

        # Записываем i-ый элемент массива X
        X[i] = temp

    # Возвращаем искомый вектор столбец X
    return X
