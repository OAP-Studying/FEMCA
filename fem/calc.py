# -*- coding: utf-8 -*-
"""
calc - отдельный модуль для расчёта конструкций
отличается от matan тем, что завязан именно на конструкции
"""
import sys
from copy import deepcopy

# Модели конструкций
from . import structure as s
# Рукописные математические функции
from . import matan as m


class FEMComput:
    """Класс для вычислений МКЭ - одномерный случай"""

    def __init__(self, line_struct: s.LineStructure):
        """
        Вызывается при создании экземпляра
        line_struct : объект конструкции состоящих
                      из конечных элементов
        """
        # Делаем копию конструкции для изменений
        self.line_struct = deepcopy(line_struct)
        # Глобальная матрица жескости конструкции
        self.K = self.line_struct.K
        # Вектор известных узловых усилий
        self.f = self.line_struct.f
        # Вектор НЕизвестных узловых перемещенией
        self.q = self.line_struct.q
        # Вычисялемые перемещения для ускорения вычислений
        self.res_q = []

    @property
    def height(self):
        """Количество строк в системе"""
        return self.K.rows

    @height.setter
    def height(self, value):
        """Нельзя менять количество строк системы"""
        raise Exception("Атрибут 'height' нельзя изменять")

    def show_equation(self, message):
        """Показать уравнение в матричном виде"""
        # Строки матрицы жёсткости представляем в виде строк python
        K = str(self.K).split('\n')
        # Строки столбца сил также как строки python
        q = str(self.q).split('\n')
        # Строки вектора неизвестных усзловых перемещений как строки python
        f = str(self.f).split('\n')

        # Вектор столбец знака умножения
        mult = []
        for i in range(self.height):
            if i == int(self.height/2):
                mult.append(' x ')
            else:
                mult.append('   ')

        # Вектор столбец знака равно
        eql = []
        for i in range(self.height):
            if i == int(self.height/2):
                eql.append(' = ')
            else:
                eql.append('   ')

        # Подсказки
        help_K = 'K'.center(len(K[0]), ' ')
        help_q = 'q'.center(len(q[0]), ' ')
        help_f = 'f'.center(len(f[0]), ' ')
        help_str = f'{help_K}   {help_q}   {help_f}\n'
        # Выводим сообщение
        print("\n"+f"{message}".center(len(help_str)-1, '-'))
        # Выводим подсказки
        print(help_str)

        # Выводим матричное уравнение
        for i in range(self.height):
            # результирующая строка матричного уравнения
            res_row = K[i] + mult[i] + q[i] + eql[i] + f[i]
            # Печатаем эту строку уравнения
            print(res_row)

    def piano_ayrons(self, i):
        """Метод Пиано-Айронса в i-ом строке i-ом столбце"""
        # Согласно методу Пиана-Айронса
        # Остальные элементы в i-ой строке приравниваем нулю
        for col in range(self.K[i].cols):
            self.K[i, col] = 0

        # остальные элементы в i-ом столбце приравниваем нулю
        # Обходим элементы выбранного столбца
        for row in range(self.height):
            self.K[row, i] = 0

        # В i-ой строке и i-ом ставим единицу
        self.K[i, i] = 1

        # То есть меняем матрицу K так (пусть закрепили в 0-ом узле):
        #  1  2  3  4      1  0  0  0
        #  5  6  7  8      0  6  7  8
        #  9 10 11 12  =>  0 10 11 12
        # 13 14 15 16      0 14 15 16

        # Осталось изменить вектор известных узловых усилий
        self.f[i] = 0

        # То есть изменили вектор f(для примера закрепили в 0-ом узле)
        #  1    0
        #  2    2
        #  3 => 3
        #  4    4

    def enter_boundary_conditions(self):
        """
        Введём граничные условия методом Пиана-Айронса
        """
        # Обходим вектор узловых перемещений
        for i in range(self.height):
            # Если в каком-то узле перемещенее равно нулю
            if self.q[i] == 0:
                # Значит в этом узле нам нужно закрепить конструкцию
                # Что немало важно, в этом узле находится заделка
                # Примеменев в этой строке метод Пиано-Айронса
                self.piano_ayrons(i)

        # Теперь надо проверить естьли в матрице жёсткости K нулевые столбцы
        for j in range(self.K.cols):
            # Является ли столбц нулевым
            is_null_col = True
            for i in range(self.K.rows):
                if self.K[i, j] != 0:
                    is_null_col = False
                    break
            # Если столбец оказался нулевым
            if is_null_col:
                # То в строке = номеру столбца вводим
                # Граничные условия методом Пиано-Айрноса
                self.K[j, j] = 1

        # Теперь обходим все строки - есть ли нулевые
        for i in range(self.K.rows):
            # Является ли строка нулевой
            is_null_row = True
            for j in range(self.K.cols):
                if self.K[i, j] != 0:
                    is_null_row = False
                    break
            # Если строка оказалась нулевой
            if is_null_row:
                # То в строке = номеру столбца вводим
                # Граничные условия методом Пиано-Айрноса
                self.K[i, i] = 1

    def find_q(self, recalculate=False):
        """
        Найти вектор неизвестных узловым перемещений
            method: метод решения систему уравнений (inv, guass)
            recalculate: пересчитать в любом случае
        """
        # если задан параметр пересчитать - то есть в любом случае
        # произвести расчёт занаво или еще не было посчитано
        if recalculate or not self.res_q:
            # Находим перемещения
            self.res_q = m.find_with_gauss(self.K, self.f)

        # возвращаем посчитанное значение вектора перемещений
        # или то, чо было вычисленно ранее
        return self.res_q

    def show_q(self):
        """Вывести узловые перемещения"""
        # Вектор неизвестных узловых перемещений как строки python
        unknown = str(self.q).split("\n")
        # Найденный вектор узловых перемещений как строки python
        known = str(self.find_q()).split("\n")

        # Вектор столбец знака равно
        eql = []
        for i in range(self.height):
            if i == int(self.height/2):
                eql.append(' = ')
            else:
                eql.append('   ')

        print("\nУзловые перемещения\n")
        for i in range(self.height):
            # Собираем строку выражения
            res_str = unknown[i] + eql[i] + known[i]
            # Выводим эту саму строку
            print(res_str)

    def apply_q_to_structure(self):
        """Нанести перемещения на конструкцию"""
        # Найдем вектор узловых перемещений
        q = self.find_q()

        # Узлы в конструкции должы быть в том же порядке, что и векторе q
        # Каждому узлу конструкции указываем соответствующее перемещение
        for i in range(len(self.line_struct.grid)):
            self.line_struct.grid[i].u = q[i*2]
            self.line_struct.grid[i].v = q[i*2+1]

    def aprox_u(self, el: s.LineFE, x: float):
        """Апрокисимация поля перемещения ОДНОГО элемената
        el: конечный элемент
        x : координа относительно элемента, в которой нужно
            вычислить перемещение, задаётся в безразмерном виде
            от 0 до 1 включительно
        """
        # 'x' или локальная координата должна быть >= 0 и <= 1
        # Иначе нужно вызывать исключенеи
        if x < 0 or x > 1:
            raise Exception(f'Координата x={x} не внутри [0, 1]')

        # Находим перемещение в начале элемента
        u1 = el.n1.u
        # Находим перемещение в конце элемента
        u2 = el.n2.u

        # Функции форм конечного элемента
        N1 = 1 - (x*el.Lx)/el.Lx
        N2 = (x*el.Lx)/el.Lx

        # Перемещение в точке x элемента
        # Это скалярное произведение вектором u и N
        return u1*N1 + u2*N2

    def show_all_aprox_u(self, step=0.25):
        """
        Показать апроксимации ПЕРЕМЕЩЕНИЙ всех элементов
        step - c какой точностью разбиваем элемент от 0 до 1 невключительно
        """
        # step или шаг должен строго быть > 0 и < 1
        # Иначе нужно вызывать исключенеи
        if step <= 0 or step >= 1:
            raise Exception(f'Параметр точности step={step} не внутри (0, 1)')

        # Выведем апроксимацию перемещений на всех элементах конструкции
        # Вспомогательное сообщение
        message = '\n'+'Апроксимация перемещений'.center(50, '-')
        print(message)
        # Обходим все элементы конструкции
        for i in range(len(self.line_struct.items)):
            # Выбираем один элемент из конструкции
            el = self.line_struct.items[i]
            # Если элемент пружина, указываем это
            if isinstance(el, s.Spring):
                print(f'\nЭлемент {i+1} - ПРУЖИНКА, Lx={el.Lx}')
            else:
                # Элемент не пружина, выводим простое сообщение
                print(f'\nЭлемент {i+1}, Lx={el.Lx}')

            # Берём точки элемента с шагом step, начиная из точки 0
            x = 0
            while x <= 1:
                # Нам нужно в любом случае вывести значение u в точке 1
                # Для этого нужно отслеживать изменение координаты x
                # ближе к концу стержня
                # Если следующая точка выходит за рамки элемента
                if x + step > 1:
                    # Приравниваем значение точки единице
                    # То есть ставим точку в конец объекта
                    x = 1
                # Выводим перемещение в точке x
                print(f'\tu({x:5.2f}) = {self.aprox_u(el, x):5.2f}')
                # Переходим к следующей точке элемента
                # с шагом step
                x += step

    def aprox_Fx(self, el: s.LineFE):
        """Апроксимация усилий в элементе"""
        # По формуле N(x) = EA*u'(x) найдем усилия
        # В нашем простом примере производная от перемещения
        # u'(x) не зависит от x, следовательно
        # Усилие в каждой точке конечного элементо
        # - это константа, и можно не передавать x

        # Находим перемещение в начале элемента
        u1 = el.n1.u
        # Находим перемещение в конце элемента
        u2 = el.n2.u

        # Производные от функции форм конечного элемента
        _N1 = -1/el.Lx
        _N2 = 1/el.Lx

        # Производная от функции перемещения u'(x)
        # Это скалярное произведение векторов u и N'
        _u = u1*_N1 + u2*_N2

        # Если элемент пружинка
        if isinstance(el, s.Spring):
            EA = el.C * el.Lx
        else:
            EA = el.E * el.A

        # находим усилие по известной формуле N(x) = EA*u'(x)
        return EA*_u

    def show_all_aprox_Fx(self):
        """Показать апроксимации Усилий всех элементов"""
        # Выведем апроксимацию перемещений на всех элементах конструкции
        # Вспомогательное сообщение
        message = '\n'+'Апроксимация УСИЛИЙ'.center(50, '-')
        print(message)

        # Обходим все элементы конструкции
        for i in range(len(self.line_struct.items)):
            # Выбираем один элемент из конструкции
            el = self.line_struct.items[i]
            # Если элемент пружина, указываем это
            if isinstance(el, s.Spring):
                review = f'Элемент {i+1} - ПРУЖИНКА, Lx={el.Lx}'
            else:
                # Элемент не пружины, выводим простое сообщение
                review = f'Элемент {i+1}, Lx={el.Lx}'

            # находим апроксимацию усилий в этом элементе
            N = self.aprox_Fx(el)
            # Добавляем к описанию конечного элемента
            review = f'{review}, Nx(0..Lx) = {N:5.2f}'
            # Выводим описание элемента
            print(review)

    def display_results(self):
        """Выводим результаты на экран"""
        # Выводим матричное уравнение
        self.show_equation("Уравнение в матричном виде")
        # Введём граничные условия методом Пиана-Айронса
        self.enter_boundary_conditions()
        # Снова выводим матричное уравнение
        self.show_equation("Введём граничные условия методом Пиана-Айронса")
        # Найдём и выведем узловые перемещения
        self.show_q()
        # Нанесём перемещения на конструкцию (копию внутри объекта self)
        self.apply_q_to_structure()
        # Выведем апроксимации перемещений для всех элементов конструкции
        self.show_all_aprox_u()
        # Выведем апроксимации усилий для всех элементов
        self.show_all_aprox_Fx()

    def save_results(self, file_name, comment=''):
        """Сохраняем результаты вычислений в файл"""
        # Открываем файл на запись
        file = open(file_name, 'w', encoding='utf8')
        # Переопределяем стандартный вывод
        sys.stdout = file
        # Выводи комментарий к результатам, если он существует
        if comment:
            print(comment)

        # Записываем результаты в файл
        self.display_results()

        # Закрываем файл
        file.close()
        # Возвращаем стандартный вывод
        sys.stdout = sys.__stdout__
